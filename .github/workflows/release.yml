name: Release LoRaCue Firmware

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      prerelease:
        description: 'Create pre-release'
        required: false
        default: false
        type: boolean
      manual_tag:
        description: 'Manual tag (e.g., v1.2.3, leave empty for GitVersion)'
        required: false
        type: string

permissions:
  contents: write

env:
  ESP_IDF_VERSION: v5.5

jobs:
  version:
    runs-on: ubuntu-latest
    name: Calculate Version and Create Tag
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag_name: ${{ steps.version.outputs.tag_name }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v6
      with:
        fetch-depth: 0
        
    - name: Install GitVersion
      uses: gittools/actions/gitversion/setup@v4.2.0
      with:
        versionSpec: '6.x'
        
    - name: Determine Version
      id: gitversion
      uses: gittools/actions/gitversion/execute@v4.2.0
      with:
        configFilePath: GitVersion.yml
    
    - name: Validate and set version
      id: version
      run: |
        GITVERSION="${{ steps.gitversion.outputs.semVer }}"
        MANUAL_TAG="${{ github.event.inputs.manual_tag }}"
        PUSHED_TAG="${{ github.ref_name }}"
        
        # Always use GitVersion semver for consistency
        VERSION="$GITVERSION"
        TAG_NAME="v$VERSION"
        
        # Determine source for logging
        if [ "${{ github.event_name }}" == "push" ] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
          echo "Tag was pushed: $PUSHED_TAG, using GitVersion: $TAG_NAME"
          
          # Warn if tag doesn't match GitVersion
          if [ "${PUSHED_TAG#v}" != "$GITVERSION" ]; then
            echo "WARNING: Pushed tag $PUSHED_TAG differs from GitVersion $TAG_NAME"
            echo "Using GitVersion for consistency"
          fi
        elif [ -n "$MANUAL_TAG" ]; then
          echo "Manual tag requested: $MANUAL_TAG, using GitVersion: $TAG_NAME"
          
          # Compare versions
          if [ "$(printf '%s\n' "$VERSION" "${MANUAL_TAG#v}" | sort -V | head -n1)" != "${MANUAL_TAG#v}" ]; then
            echo "ERROR: GitVersion $TAG_NAME is above manual tag $MANUAL_TAG"
            echo "Cannot use manual tag that is older than calculated version"
            exit 1
          fi
        else
          echo "Auto-generating tag from GitVersion: $TAG_NAME"
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        
        if [ "${{ steps.gitversion.outputs.preReleaseTag }}" != "" ] || [ "${{ github.event.inputs.prerelease }}" == "true" ]; then
          echo "is_prerelease=true" >> $GITHUB_OUTPUT
        else
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Create and push tag
      if: github.event_name != 'push' || !startsWith(github.ref, 'refs/tags/')
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        TAG_NAME="${{ steps.version.outputs.tag_name }}"
        
        # Check if tag already exists
        if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
          echo "Tag $TAG_NAME already exists, skipping creation"
        else
          echo "Creating tag $TAG_NAME"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          
          # Use GitHub CLI to push tag (has proper permissions)
          gh api repos/${{ github.repository }}/git/refs \
            -X POST \
            -f ref="refs/tags/$TAG_NAME" \
            -f sha="${{ github.sha }}"
        fi

  build-matrix:
    runs-on: ubuntu-latest
    needs: version
    strategy:
      fail-fast: false
      matrix:
        model:
          - name: "alpha"
            display_name: "LC-Alpha"
            board: "heltec_v3"
            board_name: "Heltec LoRa V3"
            target: "esp32s3"
            description: "Prototype with single onboard button"
            flash_size: "8MB"
          - name: "alpha+"
            display_name: "LC-Alpha+"
            board: "heltec_v3"
            board_name: "Heltec LoRa V3"
            target: "esp32s3"
            description: "Enhanced prototype with two separate buttons"
            flash_size: "8MB"
          # TODO: Enable when ui_rich component is complete
          # - name: "gamma"
          #   display_name: "LC-Gamma"
          #   board: "lilygo_t5"
          #   board_name: "LilyGO T5 Pro"
          #   target: "esp32s3"
          #   description: "Professional with 4.7\" E-paper display and touch"
          #   flash_size: "16MB"
    
    name: Build ${{ matrix.model.display_name }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v6
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Install GitVersion in build environment
      shell: bash
      run: |
        wget https://github.com/GitTools/GitVersion/releases/download/6.0.5/gitversion-linux-x64-6.0.5.tar.gz
        tar -xzf gitversion-linux-x64-6.0.5.tar.gz
        chmod +x gitversion
        sudo mv gitversion /usr/local/bin/
        gitversion version
    
    - name: Cache ESP-IDF
      uses: actions/cache@v5
      with:
        path: |
          ~/.espressif
          ~/esp/esp-idf
        key: esp-idf-${{ env.ESP_IDF_VERSION }}
    
    - name: Install ESP-IDF
      shell: bash
      run: |
        if [ ! -d "$HOME/esp/esp-idf" ]; then
          echo "üì• Installing ESP-IDF ${{ env.ESP_IDF_VERSION }}..."
          mkdir -p ~/esp
          cd ~/esp
          git clone --recursive --branch ${{ env.ESP_IDF_VERSION }} --depth 1 https://github.com/espressif/esp-idf.git
          cd esp-idf
          ./install.sh esp32s3
        else
          echo "‚úÖ ESP-IDF already installed (from cache)"
        fi
        echo "ESP_IDF=$HOME/esp/esp-idf" >> $GITHUB_ENV
    
    - name: Install build dependencies
      shell: bash
      run: |
        echo "üì¶ Installing build dependencies..."
        npm install -g lv_font_conv
        cargo install png2lvgl
        pip install cryptography
        echo "$HOME/.cargo/bin" >> $GITHUB_PATH
    
    - name: Install mklittlefs
      shell: bash
      run: |
        echo "üì• Installing mklittlefs..."
        curl -L -o mklittlefs.tar.gz https://github.com/earlephilhower/mklittlefs/releases/download/4.0.1/x86_64-linux-gnu-mklittlefs-cc32c94.tar.gz
        tar -xzf mklittlefs.tar.gz
        chmod +x */mklittlefs
        sudo cp */mklittlefs /usr/local/bin/mklittlefs
        mklittlefs --version || echo "‚úÖ mklittlefs installed"
    
    - name: Build WebUI
      shell: bash
      run: |
        echo "üåê Building WebUI..."
        cd web-interface
        npm install
        npm run build
        cd ..
        echo "‚úÖ WebUI built"
    
    - name: Create LittleFS image
      shell: bash
      run: |
        echo "üì¶ Creating LittleFS image..."
        mkdir -p build
        mklittlefs -c web-interface/out -b 4096 -p 256 -s 0x1C0000 build/webui-littlefs.bin
        ls -lh build/webui-littlefs.bin
        echo "‚úÖ WebUI LittleFS image created"
    
    - name: Build firmware with make
      shell: bash
      env:
        CI: true
      run: |
        echo "üî® Building ${{ matrix.model.display_name }}..."
        source $ESP_IDF/export.sh
        make build MODEL=${{ matrix.model.name }}
    
    - name: Extract and validate firmware manifest
      id: manifest
      shell: bash
      run: |
        python3 << 'EOF'
        import struct
        import sys
        import os
        
        # Binary name is loracue.bin (project name)
        binary_name = "loracue.bin"
        
        # ESP-IDF app descriptor is at fixed offset 0x20 in the binary
        with open(f'build/{binary_name}', 'rb') as f:
            f.seek(0x20)
            data = f.read(256)
            
            # esp_app_desc_t structure offsets
            magic_word = struct.unpack('<I', data[0:4])[0]
            version = data[16:48].decode('utf-8', errors='ignore').rstrip('\x00')
            project_name = data[48:80].decode('utf-8', errors='ignore').rstrip('\x00')
            time = data[80:96].decode('utf-8', errors='ignore').rstrip('\x00')
            date = data[96:112].decode('utf-8', errors='ignore').rstrip('\x00')
            idf_ver = data[112:144].decode('utf-8', errors='ignore').rstrip('\x00')
            
            print(f"‚úì ESP-IDF app descriptor found at 0x20")
            print(f"  Magic: 0x{magic_word:08X}")
            print(f"  Project Name: {project_name}")
            print(f"  Version: {version}")
            print(f"  Build: {date} {time}")
            print(f"  IDF Version: {idf_ver}")
            
            # Export for GitHub Actions
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write(f"board_id=${{ matrix.model.board }}\n")
                f.write(f"model=${{ matrix.model.display_name }}\n")
                f.write(f"fw_version={version}\n")
            
            print(f"‚úì Manifest validated: ${{ matrix.model.display_name }} ({project_name}) v{version}")
        EOF
    
    - name: Calculate checksums
      id: checksums
      run: |
        BINARY_NAME="loracue.bin"
        FIRMWARE_SHA=$(sha256sum build/$BINARY_NAME | cut -d' ' -f1)
        BOOTLOADER_SHA=$(sha256sum build/bootloader/bootloader.bin | cut -d' ' -f1)
        PARTITION_SHA=$(sha256sum build/partition_table/partition-table.bin | cut -d' ' -f1)
        WEBUI_SHA=$(sha256sum build/webui-littlefs.bin | cut -d' ' -f1)
        
        echo "firmware_sha256=$FIRMWARE_SHA" >> $GITHUB_OUTPUT
        echo "bootloader_sha256=$BOOTLOADER_SHA" >> $GITHUB_OUTPUT
        echo "partition_sha256=$PARTITION_SHA" >> $GITHUB_OUTPUT
        echo "webui_sha256=$WEBUI_SHA" >> $GITHUB_OUTPUT
        
        # Save to files in workspace (not build directory)
        echo "$FIRMWARE_SHA" > ${BINARY_NAME}.sha256
        echo "$BOOTLOADER_SHA" > bootloader.bin.sha256
        echo "$PARTITION_SHA" > partition-table.bin.sha256
        echo "$WEBUI_SHA" > webui-littlefs.bin.sha256
    
    - name: Sign firmware binaries
      env:
        SIGNING_KEY: ${{ secrets.FIRMWARE_SIGNING_KEY }}
      run: |
        # Save private key to temp file
        echo "$SIGNING_KEY" > /tmp/signing_key.pem
        chmod 600 /tmp/signing_key.pem
        
        BINARY_NAME="loracue.bin"
        
        # Copy binaries to workspace for signing
        cp build/$BINARY_NAME .
        cp build/bootloader/bootloader.bin .
        cp build/partition_table/partition-table.bin .
        cp build/webui-littlefs.bin .
        
        # Sign all binaries in workspace
        python3 scripts/sign_firmware.py $BINARY_NAME /tmp/signing_key.pem
        python3 scripts/sign_firmware.py bootloader.bin /tmp/signing_key.pem
        python3 scripts/sign_firmware.py partition-table.bin /tmp/signing_key.pem
        python3 scripts/sign_firmware.py webui-littlefs.bin /tmp/signing_key.pem
        
        # Clean up private key
        rm -f /tmp/signing_key.pem
    
    - name: Generate manifest
      env:
        SIGNING_KEY: ${{ secrets.FIRMWARE_SIGNING_KEY }}
      run: |
        # Save private key to temp file
        echo "$SIGNING_KEY" > /tmp/signing_key.pem
        chmod 600 /tmp/signing_key.pem
        
        BINARY_NAME="loracue.bin"
        
        # Generate and sign manifest (all files are in workspace)
        python3 scripts/generate_manifest.py \
          "${{ needs.version.outputs.version }}" \
          "${{ needs.version.outputs.is_prerelease == 'true' && 'prerelease' || 'release' }}" \
          "${{ github.sha }}" \
          "${{ needs.version.outputs.tag_name }}" \
          "${{ matrix.model.display_name }}" \
          "${{ matrix.model.board }}" \
          "$BINARY_NAME" \
          "bootloader.bin" \
          "partition-table.bin" \
          "webui-littlefs.bin" \
          "/tmp/signing_key.pem"
        
        # Clean up private key
        rm -f /tmp/signing_key.pem
    
    - name: Generate firmware package
      run: |
        VERSION="${{ needs.version.outputs.version }}"
        MODEL="${{ matrix.model.name }}"
        DISPLAY_NAME="${{ matrix.model.display_name }}"
        BINARY_NAME="loracue.bin"
        
        mkdir -p release/$MODEL
        
        # Copy binaries from workspace (already copied there for signing)
        cp $BINARY_NAME release/$MODEL/firmware.bin
        cp bootloader.bin release/$MODEL/
        cp partition-table.bin release/$MODEL/
        cp webui-littlefs.bin release/$MODEL/
        
        # Copy checksums from workspace
        cp ${BINARY_NAME}.sha256 release/$MODEL/firmware.bin.sha256
        cp bootloader.bin.sha256 release/$MODEL/
        cp partition-table.bin.sha256 release/$MODEL/
        cp webui-littlefs.bin.sha256 release/$MODEL/
        
        # Copy signatures from workspace
        cp ${BINARY_NAME}.sig release/$MODEL/firmware.bin.sig
        cp bootloader.bin.sig release/$MODEL/
        cp partition-table.bin.sig release/$MODEL/
        cp webui-littlefs.bin.sig release/$MODEL/
        
        # Copy manifest and signature from workspace
        cp manifest.json release/$MODEL/
        cp manifest.json.sig release/$MODEL/
        
        # Generate compact README
        cat > release/$MODEL/README.md << EOF
        # LoRaCue Firmware v${VERSION}
        
        **Model**: ${DISPLAY_NAME}
        **Board**: ${{ matrix.model.board }}
        **Target**: ${{ matrix.model.target }}
        **Flash Size**: 8MB
        **Description**: ${{ matrix.model.description }}
        **Build Date**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        **Commit**: ${{ github.sha }}
        **Firmware Version**: \`v${VERSION}\`
        **SHA256**: \`${{ steps.checksums.outputs.firmware_sha256 }}\`
        
        ## üìã Package Contents
        
        - \`firmware.bin\` - Main firmware binary
        - \`bootloader.bin\` - ESP32 bootloader
        - \`partition-table.bin\` - Partition table
        - \`webui-littlefs.bin\` - Web UI filesystem image
        - \`manifest.json\` - Firmware manifest with metadata
        - \`*.sha256\` - SHA256 checksums for verification
        - \`*.sig\` - Ed25519 signatures for authenticity verification
        
        ## üìö Documentation
        
        - **Firmware Repository**: https://github.com/LoRaCue/loracue
        - **Manager Tool**: https://github.com/LoRaCue/loracue-manager-apple
        - **Issues**: https://github.com/LoRaCue/loracue/issues
        - **Wiki**: https://github.com/LoRaCue/loracue/wiki
        
        ## üèôÔ∏è Made with ‚ù§Ô∏è in Hannover üá©üá™
        EOF
    
    - name: Create firmware archive
      run: |
        cd release/${{ matrix.model.name }}
        zip -r ../loracue-${{ matrix.model.name }}-v${{ needs.version.outputs.version }}.zip .
    
    - name: Upload firmware package
      uses: actions/upload-artifact@v5
      with:
        name: loracue-${{ matrix.model.name }}-v${{ needs.version.outputs.version }}
        path: release/loracue-${{ matrix.model.name }}-v${{ needs.version.outputs.version }}.zip
        retention-days: 90
    
    - name: Upload manifest
      uses: actions/upload-artifact@v5
      with:
        name: ${{ matrix.model.name }}-manifest-v${{ needs.version.outputs.version }}
        path: release/${{ matrix.model.name }}/manifest.json
        retention-days: 90

  generate-changelog:
    runs-on: ubuntu-latest
    needs: version
    name: Generate Release Notes
    outputs:
      changelog: ${{ steps.changelog.outputs.changelog }}
      breaking_changes: ${{ steps.changelog.outputs.breaking_changes }}
      known_issues: ${{ steps.changelog.outputs.known_issues }}
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v6
      with:
        fetch-depth: 0
        
    - name: Generate commit-based changelog
      id: changelog
      run: |
        # Get previous tag
        PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
        
        if [ -z "$PREV_TAG" ]; then
          echo "No previous tag found, using all commits"
          COMMIT_RANGE="HEAD"
        else
          echo "Generating changelog from $PREV_TAG to HEAD"
          COMMIT_RANGE="$PREV_TAG..HEAD"
        fi
        
        # Parse commits by conventional commit type
        FEATURES=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^feat(\(.+\))?:" | sed 's/^feat[^:]*: /- /' || echo "")
        FIXES=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^fix(\(.+\))?:" | sed 's/^fix[^:]*: /- /' || echo "")
        DOCS=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^docs(\(.+\))?:" | sed 's/^docs[^:]*: /- /' || echo "")
        PERF=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^perf(\(.+\))?:" | sed 's/^perf[^:]*: /- /' || echo "")
        REFACTOR=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^refactor(\(.+\))?:" | sed 's/^refactor[^:]*: /- /' || echo "")
        OTHER=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -vE "^(feat|fix|docs|perf|refactor)(\(.+\))?:" | sed 's/^/- /' || echo "")
        
        # Detect breaking changes (BREAKING CHANGE: or ! in commit)
        BREAKING=$(git log $COMMIT_RANGE --pretty=format:"%s%n%b" --no-merges | grep -A 10 -E "(^[a-z]+(\(.+\))?!:|BREAKING CHANGE:)" | grep -v "^--$" || echo "")
        
        # Build changelog
        CHANGELOG=""
        
        if [ -n "$FEATURES" ]; then
          CHANGELOG+="## üöÄ Features"$'\n\n'"$FEATURES"$'\n\n'
        fi
        
        if [ -n "$FIXES" ]; then
          CHANGELOG+="## üêõ Bug Fixes"$'\n\n'"$FIXES"$'\n\n'
        fi
        
        if [ -n "$PERF" ]; then
          CHANGELOG+="## ‚ö° Performance"$'\n\n'"$PERF"$'\n\n'
        fi
        
        if [ -n "$DOCS" ]; then
          CHANGELOG+="## üìö Documentation"$'\n\n'"$DOCS"$'\n\n'
        fi
        
        if [ -n "$REFACTOR" ]; then
          CHANGELOG+="## üîß Refactoring"$'\n\n'"$REFACTOR"$'\n\n'
        fi
        
        if [ -n "$OTHER" ]; then
          CHANGELOG+="## üìã Other Changes"$'\n\n'"$OTHER"$'\n\n'
        fi
        
        if [ -z "$CHANGELOG" ]; then
          CHANGELOG="No changes in this release"
        fi
        
        # Save outputs
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo -e "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "breaking_changes<<EOF" >> $GITHUB_OUTPUT
        echo -e "$BREAKING" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
    - name: Check for known issues
      id: known_issues
      run: |
        # Check if KNOWN_ISSUES.md exists
        if [ -f "KNOWN_ISSUES.md" ]; then
          ISSUES=$(cat KNOWN_ISSUES.md)
          echo "known_issues<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        else
          echo "known_issues=" >> $GITHUB_OUTPUT
        fi

  create-release:
    runs-on: ubuntu-latest
    needs: [version, build-matrix, generate-changelog]
    name: Create GitHub Release
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v6
      
    - name: Download all firmware packages
      uses: actions/download-artifact@v7
      with:
        path: firmware-packages/
        
    - name: Prepare release assets
      run: |
        mkdir -p release-assets
        find firmware-packages -name "*.zip" -exec cp {} release-assets/ \;
        
        # Create combined manifests.json with proper JSON formatting
        python3 <<'EOF'
        import json
        import glob
        import re
        
        manifests = []
        tag_name = "${{ needs.version.outputs.tag_name }}"
        version = "${{ needs.version.outputs.version }}"
        
        # Map display names to artifact names (from matrix.model.name)
        model_name_map = {
            "LC-Alpha": "alpha",
            "LC-Alpha+": "alpha+",
            "LC-Gamma": "gamma"
        }
        
        for manifest_file in sorted(glob.glob("firmware-packages/*-manifest-*/manifest.json")):
            with open(manifest_file, 'r') as f:
                manifest = json.load(f)
                
            # Get model display name from manifest
            model_display = manifest.get("model", "")
            
            # Map to artifact name
            model_slug = model_name_map.get(model_display, model_display.lower().replace(" ", "-"))
            
            # Add download_url using artifact naming convention
            manifest["download_url"] = f"https://github.com/LoRaCue/loracue/releases/download/{tag_name}/loracue-{model_slug}-v{version}.zip"
            
            manifests.append(manifest)
        
        with open("release-assets/manifests.json", 'w') as f:
            json.dump(manifests, f, indent=2)
        
        print(f"‚úì Created combined manifests.json with {len(manifests)} models")
        for m in manifests:
            print(f"  - {m['model']} ({m['board_id']}) -> {m['download_url']}")
        EOF
        
        echo "Combined manifests.json:"
        cat release-assets/manifests.json
        
        ls -lah release-assets/
    
    - name: Sign manifests.json
      env:
        SIGNING_KEY: ${{ secrets.FIRMWARE_SIGNING_KEY }}
      run: |
        echo "$SIGNING_KEY" > /tmp/signing_key.pem
        chmod 600 /tmp/signing_key.pem
        
        cd release-assets
        python3 ../scripts/sign_firmware.py manifests.json /tmp/signing_key.pem
        
        rm -f /tmp/signing_key.pem
        
        echo "‚úì Created manifests.json.sig"
        ls -lah manifests.json*
    
    - name: Get build timestamp
      id: timestamp
      run: echo "date=$(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_OUTPUT
        
    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.version.outputs.tag_name }}
        name: LoRaCue v${{ needs.version.outputs.version }}
        body: |
          ${{ needs.generate-changelog.outputs.breaking_changes != '' && format('# ‚ö†Ô∏è BREAKING CHANGES
          
          {0}
          
          ', needs.generate-changelog.outputs.breaking_changes) || '' }}${{ needs.generate-changelog.outputs.known_issues != '' && format('# üêõ Known Issues
          
          {0}
          
          ', needs.generate-changelog.outputs.known_issues) || '' }}
          # üì¶ Product Models
          
          | Model | Board | Hardware | Description |
          |-------|-------|----------|-------------|
          | **LC-Alpha** | Heltec V3 | 1 onboard button | Prototype with single button |
          | **LC-Alpha+** | Heltec V3 | 2 separate buttons | Enhanced prototype with prev/next buttons |
          | **LC-Gamma** | LilyGO T5 Pro | E-paper + touch | Professional with 4.7" display |
          
          # üì• Installation
          
          Use **[LoRaCue Manager](https://github.com/LoRaCue/loracue-manager)** to flash firmware to your devices.
          
          LoRaCue Manager provides:
          - ‚úÖ Automatic device detection
          - ‚úÖ One-click firmware updates
          - ‚úÖ Integrity verification
          - ‚úÖ Cross-platform support (Windows, macOS, Linux)
          
          # üîê Security & Verification
          
          All firmware binaries include:
          - ‚úÖ SHA256 checksums for integrity verification
          - ‚úÖ Embedded firmware manifest with board ID
          - ‚úÖ OTA compatibility checking (prevents wrong board flashing)
          
          # üîÑ Changelog
          
          ${{ needs.generate-changelog.outputs.changelog }}
          
          # üõ†Ô∏è Technical Details
          
          - **ESP-IDF**: ${{ env.ESP_IDF_VERSION }}
          - **Build Date**: ${{ steps.timestamp.outputs.date }}
          - **Commit**: ${{ github.sha }}
          - **Branch**: ${{ github.ref_name }}
          
          # üìö Documentation
          
          - **Installation Guide**: https://github.com/LoRaCue/loracue/wiki/Installation
          - **User Manual**: https://github.com/LoRaCue/loracue/wiki
          - **API Documentation**: https://github.com/LoRaCue/loracue/wiki/API
          
          ---
          
          **üèôÔ∏è Made with ‚ù§Ô∏è in Hannover üá©üá™**
        files: release-assets/*
        prerelease: ${{ needs.version.outputs.is_prerelease == 'true' }}
        generate_release_notes: false
        draft: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Notify release.loracue.com
      run: |
        curl -X POST \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.RELEASE_REPO_TOKEN }}" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          https://api.github.com/repos/LoRaCue/release.loracue.com/dispatches \
          -d '{"event_type":"new_release","client_payload":{"version":"${{ needs.version.outputs.version }}","tag":"${{ needs.version.outputs.tag_name }}"}}'
