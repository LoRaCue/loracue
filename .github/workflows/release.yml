name: Release LoRaCue Firmware

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      prerelease:
        description: 'Create pre-release'
        required: false
        default: false
        type: boolean
      manual_tag:
        description: 'Manual tag (e.g., v1.2.3, leave empty for GitVersion)'
        required: false
        type: string

permissions:
  contents: write

env:
  ESP_IDF_VERSION: v5.5

jobs:
  version:
    runs-on: ubuntu-latest
    name: Calculate Version and Create Tag
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag_name: ${{ steps.version.outputs.tag_name }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
      with:
        fetch-depth: 0
        
    - name: Install GitVersion
      uses: gittools/actions/gitversion/setup@v4.1.0
      with:
        versionSpec: '6.x'
        
    - name: Determine Version
      id: gitversion
      uses: gittools/actions/gitversion/execute@v4.1.0
      with:
        configFilePath: GitVersion.yml
    
    - name: Validate and set version
      id: version
      run: |
        GITVERSION="${{ steps.gitversion.outputs.semVer }}"
        MANUAL_TAG="${{ github.event.inputs.manual_tag }}"
        PUSHED_TAG="${{ github.ref_name }}"
        
        # Determine source
        if [ "${{ github.event_name }}" == "push" ] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
          # Tag was pushed - validate it
          VERSION="${PUSHED_TAG#v}"
          TAG_NAME="$PUSHED_TAG"
          echo "Using pushed tag: $TAG_NAME"
          
          # Validate tag format
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
            echo "ERROR: Invalid tag format: $TAG_NAME"
            echo "Expected format: v1.2.3 or v1.2.3-alpha.1"
            exit 1
          fi
          
          # Warn if tag doesn't match GitVersion
          if [ "$VERSION" != "$GITVERSION" ]; then
            echo "WARNING: Pushed tag v$VERSION differs from GitVersion v$GITVERSION"
            echo "This may indicate the tag was created manually"
          fi
        elif [ -n "$MANUAL_TAG" ]; then
          # Manual tag specified
          VERSION="${MANUAL_TAG#v}"
          TAG_NAME="v$VERSION"
          echo "Manual tag requested: $TAG_NAME"
          
          # Compare versions
          if [ "$(printf '%s\n' "$VERSION" "$GITVERSION" | sort -V | head -n1)" != "$GITVERSION" ]; then
            echo "ERROR: Manual tag v$VERSION is below GitVersion v$GITVERSION"
            echo "Cannot create tag that is older than calculated version"
            exit 1
          fi
        else
          # Auto-generate from GitVersion
          VERSION="$GITVERSION"
          TAG_NAME="v$VERSION"
          echo "Auto-generating tag from GitVersion: $TAG_NAME"
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        
        if [ "${{ steps.gitversion.outputs.preReleaseTag }}" != "" ] || [ "${{ github.event.inputs.prerelease }}" == "true" ]; then
          echo "is_prerelease=true" >> $GITHUB_OUTPUT
        else
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Create and push tag
      if: github.event_name != 'push' || !startsWith(github.ref, 'refs/tags/')
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        TAG_NAME="${{ steps.version.outputs.tag_name }}"
        
        # Check if tag already exists
        if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
          echo "Tag $TAG_NAME already exists, skipping creation"
        else
          echo "Creating tag $TAG_NAME"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          
          # Use GitHub CLI to push tag (has proper permissions)
          gh api repos/${{ github.repository }}/git/refs \
            -X POST \
            -f ref="refs/tags/$TAG_NAME" \
            -f sha="${{ github.sha }}"
        fi

  build-matrix:
    runs-on: ubuntu-latest
    needs: version
    strategy:
      fail-fast: false
      matrix:
        board:
          - name: "heltec_v3"
            display_name: "Heltec LoRa V3"
            target: "esp32s3"
            description: "ESP32-S3 with SX1262 LoRa (868/915MHz) and SSD1306 OLED"
            flash_size: "8MB"
            sdkconfig: "sdkconfig.heltec_v3"
          - name: "lilygo_t5"
            display_name: "LilyGO T5 4.7\" E-Paper"
            target: "esp32s3"
            description: "ESP32-S3 with ED047TC1 E-Paper (960x540, 16 grayscale) and GT911 touch"
            flash_size: "16MB"
            sdkconfig: "sdkconfig.lilygo_t5"
    
    name: Build ${{ matrix.board.display_name }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Cache ESP-IDF
      uses: actions/cache@v4
      with:
        path: |
          ~/.espressif
          ~/.cache/pip
        key: esp-idf-${{ env.ESP_IDF_VERSION }}-${{ matrix.board.target }}-${{ hashFiles('**/CMakeLists.txt') }}
        restore-keys: |
          esp-idf-${{ env.ESP_IDF_VERSION }}-${{ matrix.board.target }}-
    
    - name: Install GitVersion in build environment
      shell: bash
      run: |
        wget https://github.com/GitTools/GitVersion/releases/download/6.0.5/gitversion-linux-x64-6.0.5.tar.gz
        tar -xzf gitversion-linux-x64-6.0.5.tar.gz
        chmod +x gitversion
        sudo mv gitversion /usr/local/bin/
        gitversion version
    
    - name: Install Python dependencies
      run: pip install cryptography
    
    - name: Build firmware with ESP-IDF
      uses: espressif/esp-idf-ci-action@v1
      with:
        esp_idf_version: ${{ env.ESP_IDF_VERSION }}
        target: ${{ matrix.board.target }}
        command: idf.py -D SDKCONFIG_DEFAULTS="${{ matrix.board.sdkconfig }}" -D BOARD_ID="${{ matrix.board.name }}" build
    
    - name: Extract and validate firmware manifest
      id: manifest
      shell: bash
      run: |
        python3 << 'EOF'
        import struct
        import sys
        import os
        
        # Binary name matches project name (board name)
        binary_name = "${{ matrix.board.name }}.bin"
        
        # ESP-IDF app descriptor is at fixed offset 0x20 in the binary
        with open(f'build/{binary_name}', 'rb') as f:
            f.seek(0x20)
            data = f.read(256)
            
            # esp_app_desc_t structure offsets
            magic_word = struct.unpack('<I', data[0:4])[0]
            version = data[16:48].decode('utf-8', errors='ignore').rstrip('\x00')
            project_name = data[48:80].decode('utf-8', errors='ignore').rstrip('\x00')
            time = data[80:96].decode('utf-8', errors='ignore').rstrip('\x00')
            date = data[96:112].decode('utf-8', errors='ignore').rstrip('\x00')
            idf_ver = data[112:144].decode('utf-8', errors='ignore').rstrip('\x00')
            
            print(f"‚úì ESP-IDF app descriptor found at 0x20")
            print(f"  Magic: 0x{magic_word:08X}")
            print(f"  Board ID (project_name): {project_name}")
            print(f"  Version: {version}")
            print(f"  Build: {date} {time}")
            print(f"  IDF Version: {idf_ver}")
            
            # Validate board_id matches matrix
            expected = "${{ matrix.board.name }}"
            if project_name != expected:
                print(f"‚úó ERROR: Board ID mismatch!")
                print(f"  Expected: {expected}")
                print(f"  Found: {project_name}")
                sys.exit(1)
            
            # Export for GitHub Actions
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write(f"board_id={project_name}\n")
                f.write(f"fw_version={version}\n")
            
            print(f"‚úì Manifest validated: {project_name} v{version}")
        EOF
    
    - name: Calculate checksums
      id: checksums
      run: |
        BINARY_NAME="${{ matrix.board.name }}.bin"
        FIRMWARE_SHA=$(sha256sum build/$BINARY_NAME | cut -d' ' -f1)
        BOOTLOADER_SHA=$(sha256sum build/bootloader/bootloader.bin | cut -d' ' -f1)
        PARTITION_SHA=$(sha256sum build/partition_table/partition-table.bin | cut -d' ' -f1)
        
        echo "firmware_sha256=$FIRMWARE_SHA" >> $GITHUB_OUTPUT
        echo "bootloader_sha256=$BOOTLOADER_SHA" >> $GITHUB_OUTPUT
        echo "partition_sha256=$PARTITION_SHA" >> $GITHUB_OUTPUT
        
        # Save to files in workspace (not build directory)
        echo "$FIRMWARE_SHA" > ${BINARY_NAME}.sha256
        echo "$BOOTLOADER_SHA" > bootloader.bin.sha256
        echo "$PARTITION_SHA" > partition-table.bin.sha256
    
    - name: Sign firmware binaries
      env:
        SIGNING_KEY: ${{ secrets.FIRMWARE_SIGNING_KEY }}
      run: |
        # Save private key to temp file
        echo "$SIGNING_KEY" > /tmp/signing_key.pem
        chmod 600 /tmp/signing_key.pem
        
        BINARY_NAME="${{ matrix.board.name }}.bin"
        
        # Copy binaries to workspace for signing
        cp build/$BINARY_NAME .
        cp build/bootloader/bootloader.bin .
        cp build/partition_table/partition-table.bin .
        
        # Sign all binaries in workspace
        python3 scripts/sign_firmware.py $BINARY_NAME /tmp/signing_key.pem
        python3 scripts/sign_firmware.py bootloader.bin /tmp/signing_key.pem
        python3 scripts/sign_firmware.py partition-table.bin /tmp/signing_key.pem
        
        # Clean up private key
        rm -f /tmp/signing_key.pem
    
    - name: Generate manifest
      env:
        SIGNING_KEY: ${{ secrets.FIRMWARE_SIGNING_KEY }}
      run: |
        # Save private key to temp file
        echo "$SIGNING_KEY" > /tmp/signing_key.pem
        chmod 600 /tmp/signing_key.pem
        
        BINARY_NAME="${{ matrix.board.name }}.bin"
        
        # Generate and sign manifest (all files are in workspace)
        python3 scripts/generate_manifest.py \
          "${{ needs.version.outputs.version }}" \
          "${{ needs.version.outputs.is_prerelease == 'true' && 'prerelease' || 'release' }}" \
          "${{ github.sha }}" \
          "${{ needs.version.outputs.tag_name }}" \
          "${{ matrix.board.name }}" \
          "$BINARY_NAME" \
          "bootloader.bin" \
          "partition-table.bin" \
          "/tmp/signing_key.pem"
        
        # Clean up private key
        rm -f /tmp/signing_key.pem
    
    - name: Generate firmware package
      run: |
        VERSION="${{ needs.version.outputs.version }}"
        BOARD="${{ matrix.board.name }}"
        DISPLAY_NAME="${{ matrix.board.display_name }}"
        BINARY_NAME="${BOARD}.bin"
        
        mkdir -p release/$BOARD
        
        # Copy binaries from workspace (already copied there for signing)
        cp $BINARY_NAME release/$BOARD/
        cp bootloader.bin release/$BOARD/
        cp partition-table.bin release/$BOARD/
        
        # Copy checksums from workspace
        cp ${BINARY_NAME}.sha256 release/$BOARD/
        cp bootloader.bin.sha256 release/$BOARD/
        cp partition-table.bin.sha256 release/$BOARD/
        
        # Copy signatures from workspace
        cp ${BINARY_NAME}.sig release/$BOARD/
        cp bootloader.bin.sig release/$BOARD/
        cp partition-table.bin.sig release/$BOARD/
        
        # Copy manifest from workspace
        cp manifest.json release/$BOARD/
        
        # README
        BUILD_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
        cat > release/$BOARD/README.md << EOFMD
        # LoRaCue Firmware v${{ needs.version.outputs.version }}
        
        **Board**: ${{ matrix.board.display_name }}  
        **Target**: ${{ matrix.board.target }}  
        **Description**: ${{ matrix.board.description }}  
        **Build Date**: $BUILD_DATE  
        **Commit**: ${{ github.sha }}
        
        ## üìã Package Contents
        
        - \`${BINARY_NAME}\` - Main firmware binary
        - \`bootloader.bin\` - ESP32 bootloader
        - \`partition-table.bin\` - Partition table
        - \`manifest.json\` - Firmware manifest with metadata
        - \`*.sha256\` - SHA256 checksums for verification
        - \`*.sig\` - RSA-4096 signatures for authenticity verification
        
        ## üîê Firmware Verification
        
        **Board ID**: \`${{ steps.manifest.outputs.board_id }}\`  
        **Firmware Version**: \`${{ steps.manifest.outputs.fw_version }}\`  
        **SHA256**: \`${{ steps.checksums.outputs.firmware_sha256 }}\`
        
        All binaries are signed with RSA-4096 for authenticity verification.
        
        ## üì• Installation
        
        Use **[LoRaCue Manager](https://github.com/LoRaCue/loracue-manager)** to flash this firmware.
        
        LoRaCue Manager provides:
        - ‚úÖ Automatic device detection
        - ‚úÖ One-click firmware updates  
        - ‚úÖ Integrity verification
        - ‚úÖ Cross-platform support (Windows, macOS, Linux)
        
        ## ‚úÖ Post-Flash Verification
        
        After flashing, the device should:
        1. Display LoRaCue logo on OLED
        2. Status LED breathing effect
        3. Buttons make LED solid when pressed
        4. Serial output shows firmware version
        
        ## üîÑ OTA Updates
        
        This firmware supports OTA updates via:
        - USB CDC commands
        - WiFi web interface
        
        **Compatibility**: Only accepts firmware with matching board ID (\`${{ steps.manifest.outputs.board_id }}\`)
        
        ## üìö Documentation
        
        - **Firmware Repository**: https://github.com/LoRaCue/loracue
        - **Manager Tool**: https://github.com/LoRaCue/loracue-manager
        - **Issues**: https://github.com/LoRaCue/loracue/issues
        - **Wiki**: https://github.com/LoRaCue/loracue/wiki
        
        ## üèôÔ∏è Made with ‚ù§Ô∏è in Hannover
        EOFMD
    
    - name: Create firmware archive
      run: |
        cd release
        zip -r loracue-${{ matrix.board.name }}-v${{ needs.version.outputs.version }}.zip ${{ matrix.board.name }}/
    
    - name: Upload firmware package
      uses: actions/upload-artifact@v4
      with:
        name: loracue-${{ matrix.board.name }}-v${{ needs.version.outputs.version }}
        path: release/loracue-${{ matrix.board.name }}-v${{ needs.version.outputs.version }}.zip
        retention-days: 90
    
    - name: Upload manifest
      uses: actions/upload-artifact@v4
      with:
        name: manifest-${{ matrix.board.name }}-v${{ needs.version.outputs.version }}
        path: release/${{ matrix.board.name }}/manifest.json
        retention-days: 90

  generate-changelog:
    runs-on: ubuntu-latest
    needs: version
    name: Generate Release Notes
    outputs:
      changelog: ${{ steps.changelog.outputs.changelog }}
      breaking_changes: ${{ steps.changelog.outputs.breaking_changes }}
      known_issues: ${{ steps.changelog.outputs.known_issues }}
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
      with:
        fetch-depth: 0
        
    - name: Generate commit-based changelog
      id: changelog
      run: |
        # Get previous tag
        PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
        
        if [ -z "$PREV_TAG" ]; then
          echo "No previous tag found, using all commits"
          COMMIT_RANGE="HEAD"
        else
          echo "Generating changelog from $PREV_TAG to HEAD"
          COMMIT_RANGE="$PREV_TAG..HEAD"
        fi
        
        # Parse commits by conventional commit type
        FEATURES=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^feat(\(.+\))?:" | sed 's/^feat[^:]*: /- /' || echo "")
        FIXES=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^fix(\(.+\))?:" | sed 's/^fix[^:]*: /- /' || echo "")
        DOCS=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^docs(\(.+\))?:" | sed 's/^docs[^:]*: /- /' || echo "")
        PERF=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^perf(\(.+\))?:" | sed 's/^perf[^:]*: /- /' || echo "")
        REFACTOR=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -E "^refactor(\(.+\))?:" | sed 's/^refactor[^:]*: /- /' || echo "")
        OTHER=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | grep -vE "^(feat|fix|docs|perf|refactor)(\(.+\))?:" | sed 's/^/- /' || echo "")
        
        # Detect breaking changes (BREAKING CHANGE: or ! in commit)
        BREAKING=$(git log $COMMIT_RANGE --pretty=format:"%s%n%b" --no-merges | grep -A 10 -E "(^[a-z]+(\(.+\))?!:|BREAKING CHANGE:)" | grep -v "^--$" | sed 's/^/- /' || echo "")
        
        # Build changelog
        CHANGELOG=""
        
        if [ -n "$FEATURES" ]; then
          CHANGELOG+="## üöÄ Features"$'\n\n'"$FEATURES"$'\n\n'
        fi
        
        if [ -n "$FIXES" ]; then
          CHANGELOG+="## üêõ Bug Fixes"$'\n\n'"$FIXES"$'\n\n'
        fi
        
        if [ -n "$PERF" ]; then
          CHANGELOG+="## ‚ö° Performance"$'\n\n'"$PERF"$'\n\n'
        fi
        
        if [ -n "$DOCS" ]; then
          CHANGELOG+="## üìö Documentation"$'\n\n'"$DOCS"$'\n\n'
        fi
        
        if [ -n "$REFACTOR" ]; then
          CHANGELOG+="## üîß Refactoring"$'\n\n'"$REFACTOR"$'\n\n'
        fi
        
        if [ -n "$OTHER" ]; then
          CHANGELOG+="## üìã Other Changes"$'\n\n'"$OTHER"$'\n\n'
        fi
        
        if [ -z "$CHANGELOG" ]; then
          CHANGELOG="No changes in this release"
        fi
        
        # Save outputs
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo -e "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "breaking_changes<<EOF" >> $GITHUB_OUTPUT
        echo -e "$BREAKING" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
    - name: Check for known issues
      id: known_issues
      run: |
        # Check if KNOWN_ISSUES.md exists
        if [ -f "KNOWN_ISSUES.md" ]; then
          ISSUES=$(cat KNOWN_ISSUES.md)
          echo "known_issues<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        else
          echo "known_issues=" >> $GITHUB_OUTPUT
        fi

  create-release:
    runs-on: ubuntu-latest
    needs: [version, build-matrix, generate-changelog]
    name: Create GitHub Release
    
    steps:
    - name: Download all firmware packages
      uses: actions/download-artifact@v5
      with:
        path: firmware-packages/
        
    - name: Prepare release assets
      run: |
        mkdir -p release-assets
        find firmware-packages -name "*.zip" -exec cp {} release-assets/ \;
        find firmware-packages -name "manifest.json" -exec cp {} release-assets/ \;
        ls -lah release-assets/
    
    - name: Get build timestamp
      id: timestamp
      run: echo "date=$(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_OUTPUT
        
    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.version.outputs.tag_name }}
        name: LoRaCue v${{ needs.version.outputs.version }}
        body: |
          # üéØ LoRaCue v${{ needs.version.outputs.version }}
          
          Enterprise LoRa presentation clicker firmware release.
          
          ${{ needs.generate-changelog.outputs.breaking_changes != '' && format('## ‚ö†Ô∏è BREAKING CHANGES{0}{0}{1}{0}{0}', '\n', needs.generate-changelog.outputs.breaking_changes) || '' }}
          ${{ needs.generate-changelog.outputs.known_issues != '' && format('## üêõ Known Issues{0}{0}{1}{0}{0}', '\n', needs.generate-changelog.outputs.known_issues) || '' }}
          ## üì¶ Supported Boards
          
          | Board | Target | Flash Size | Description |
          |-------|--------|------------|-------------|
          | **Heltec LoRa V3** | ESP32-S3 | 8MB | SX1262 LoRa (868/915MHz) + SSD1306 OLED |
          | **LilyGO T5 4.7"** | ESP32-S3 | 16MB | ED047TC1 E-Paper (960√ó540, 16 grayscale) + GT911 touch |
          
          ## üì• Installation
          
          Use **[LoRaCue Manager](https://github.com/LoRaCue/loracue-manager)** to flash firmware to your devices.
          
          LoRaCue Manager provides:
          - ‚úÖ Automatic device detection
          - ‚úÖ One-click firmware updates
          - ‚úÖ Integrity verification
          - ‚úÖ Cross-platform support (Windows, macOS, Linux)
          
          ## üîê Security & Verification
          
          All firmware binaries include:
          - ‚úÖ SHA256 checksums for integrity verification
          - ‚úÖ Embedded firmware manifest with board ID
          - ‚úÖ OTA compatibility checking (prevents wrong board flashing)
          
          ## üîÑ Changelog
          
          ${{ needs.generate-changelog.outputs.changelog }}
          
          ## üõ†Ô∏è Technical Details
          
          - **ESP-IDF**: ${{ env.ESP_IDF_VERSION }}
          - **Build Date**: ${{ steps.timestamp.outputs.date }}
          - **Commit**: ${{ github.sha }}
          - **Branch**: ${{ github.ref_name }}
          
          ## üìö Documentation
          
          - **Installation Guide**: https://github.com/LoRaCue/loracue/wiki/Installation
          - **User Manual**: https://github.com/LoRaCue/loracue/wiki
          - **API Documentation**: https://github.com/LoRaCue/loracue/wiki/API
          
          ---
          
          **üèôÔ∏è Made with ‚ù§Ô∏è in Hannover**
        files: release-assets/*
        prerelease: ${{ needs.version.outputs.is_prerelease == 'true' }}
        generate_release_notes: false
        draft: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Trigger release index update
      run: |
        curl -X POST \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.RELEASE_REPO_TOKEN }}" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          https://api.github.com/repos/LoRaCue/release.loracue.com/dispatches \
          -d '{"event_type":"new_release","client_payload":{"version":"${{ needs.version.outputs.version }}","tag":"${{ needs.version.outputs.tag_name }}"}}'
